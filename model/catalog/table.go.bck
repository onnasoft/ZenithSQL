package catalog

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"time"

	"github.com/onnasoft/ZenithSQL/core/buffer"
	"github.com/onnasoft/ZenithSQL/model/entity"
	"github.com/onnasoft/ZenithSQL/model/record"
	"github.com/sirupsen/logrus"
)

const (
	FileDataSchema = "data.schema.json"
	FileMetaSchema = "meta.schema.json"
	FileDataBin    = "data.bin"
	FileMetaBin    = "meta.bin"
	FileIndex      = "index.idx"
	FileStats      = "stats.bin"
	FileLog        = "wal.log"
)

type Table struct {
	Name           string
	BasePath       string
	PathDataSchema string
	PathMetaSchema string
	PathDataBin    string
	PathMetaBin    string
	PathIndex      string
	PathStats      string
	PathLog        string
	SchemaData     *entity.Schema
	SchemaMeta     *entity.Schema
	StatsSchema    *entity.Schema
	BufData        *buffer.Buffer
	BufMeta        *buffer.Buffer
	BufIndex       *buffer.Buffer
	BufStats       *buffer.Buffer
	BufLog         *buffer.Buffer
	Logger         *logrus.Logger
	Stats          *entity.Entity
	RowCount       atomic.Uint64
	RowSize        atomic.Int32
	insertMutex    sync.Mutex
	importMutex    sync.Mutex
}

type TableConfig struct {
	Name   string
	Path   string
	Schema *entity.Schema
	Logger *logrus.Logger
}

func NewTable(cfg *TableConfig) (*Table, error) {
	if cfg.Schema == nil {
		return nil, errors.New("schema cannot be nil")
	}

	tableDir := filepath.Join(cfg.Path, cfg.Name)
	if err := os.MkdirAll(tableDir, os.ModePerm); err != nil {
		return nil, fmt.Errorf("failed to create table directory: %w", err)
	}

	cfg.Schema.Lock()
	table, err := OpenTable(cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to open table: %w", err)
	}

	if err = saveSchema(table.PathDataSchema, cfg.Schema); err != nil {
		return nil, fmt.Errorf("failed to save schema: %w", err)
	}

	return table, nil
}

func OpenTable(cfg *TableConfig) (*Table, error) {
	if err := validateConfig(cfg); err != nil {
		return nil, err
	}

	base := filepath.Join(cfg.Path, cfg.Name)
	if err := ensureTableDirectoryExists(base); err != nil {
		return nil, err
	}

	metaSchema, err := loadOrCreateMeta(filepath.Join(base, FileMetaSchema))
	if err != nil {
		return nil, err
	}

	if err := loadOrLockSchema(cfg, filepath.Join(base, FileDataSchema)); err != nil {
		return nil, err
	}

	t := &Table{
		Name:           cfg.Name,
		BasePath:       cfg.Path,
		PathDataSchema: filepath.Join(base, FileDataSchema),
		PathMetaSchema: filepath.Join(base, FileMetaSchema),
		PathDataBin:    filepath.Join(base, FileDataBin),
		PathMetaBin:    filepath.Join(base, FileMetaBin),
		PathIndex:      filepath.Join(base, FileIndex),
		PathStats:      filepath.Join(base, FileStats),
		PathLog:        filepath.Join(base, FileLog),
		SchemaMeta:     metaSchema,
		SchemaData:     cfg.Schema,
		StatsSchema:    initStatsSchema(),
		Logger:         cfg.Logger,
	}

	if err := t.initBuffers(); err != nil {
		return nil, fmt.Errorf("failed to initialize buffers: %w", err)
	}

	if err := t.loadOrInitStats(); err != nil {
		return nil, fmt.Errorf("failed to initialize stats: %w", err)
	}

	return t, nil
}

func (t *Table) initBuffers() error {
	var err error

	if err = os.MkdirAll(t.BasePath, os.ModePerm); err != nil {
		return fmt.Errorf("failed to create base path: %w", err)
	}

	if t.BufMeta, err = buffer.NewBuffer(t.PathMetaBin); err != nil {
		return fmt.Errorf("failed to open meta buffer: %w", err)
	}
	if t.BufData, err = buffer.NewBuffer(t.PathDataBin); err != nil {
		return fmt.Errorf("failed to open data buffer: %w", err)
	}
	if t.BufIndex, err = buffer.NewBuffer(t.PathIndex); err != nil {
		return fmt.Errorf("failed to open index buffer: %w", err)
	}
	size := int64(t.StatsSchema.Size())
	if t.BufStats, err = buffer.NewBufferWithSize(t.PathStats, size); err != nil {
		return fmt.Errorf("failed to open stats buffer: %w", err)
	}
	if t.BufLog, err = buffer.NewBuffer(t.PathLog); err != nil {
		return fmt.Errorf("failed to open log buffer: %w", err)
	}

	if err := os.WriteFile(t.PathLog, []byte(""), 0644); err != nil {
		return fmt.Errorf("failed to initialize log file: %w", err)
	}

	return nil
}

func (t *Table) loadOrInitStats() error {
	stats, err := entity.NewEntity(&entity.EntityConfig{
		Schema: t.StatsSchema,
		RW:     buffer.NewReadWriter(t.BufStats),
	})
	if err != nil {
		return fmt.Errorf("failed to create stats entity: %w", err)
	}
	t.Stats = stats

	if !stats.IsSetted() {
		t.RowCount.Store(0)
		t.RowSize.Store(int32(t.SchemaData.Size()))
		if err := stats.SetValue("created_at", time.Now()); err != nil {
			return fmt.Errorf("failed to set created_at: %w", err)
		}

		if err := stats.Save(); err != nil {
			return fmt.Errorf("failed to save stats: %w", err)
		}
	} else {
		t.RowCount.Store(stats.GetValue("rows").(uint64))
		t.RowSize.Store(stats.GetValue("row_size").(int32))
	}

	return nil
}

func (t *Table) SaveStats() error {
	if t.Stats == nil {
		return fmt.Errorf("stats entity is nil")
	}

	t.Stats.SetValue("rows", t.RowCount.Load())
	t.Stats.SetValue("row_size", t.RowSize.Load())
	t.Stats.SetValue("updated_at", time.Now())

	if err := t.Stats.Save(); err != nil {
		return fmt.Errorf("failed to save stats: %w", err)
	}
	if err := t.BufStats.Sync(); err != nil {
		return fmt.Errorf("failed to sync stats buffer: %w", err)
	}

	fmt.Println("Stats saved successfully")

	return nil
}

func (t *Table) SetRows(rows uint64) {
	t.RowCount.Store(rows)
}

func (t *Table) GetRows() uint64 {
	return t.RowCount.Load()
}

func (t *Table) GetRowSize() int32 {
	return t.RowSize.Load()
}

func (t *Table) GetNextID() uint64 {
	return t.RowCount.Add(1)
}

func (t *Table) NewEntity() *entity.Entity {
	ent, err := entity.NewEntity(&entity.EntityConfig{
		Schema: t.SchemaData,
		RW:     buffer.NewReadWriter(t.BufData),
	})
	if err != nil {
		t.Logger.Fatal(err)
	}
	return ent
}

func (t *Table) NewMetaEntity() *entity.Entity {
	meta, err := entity.NewEntity(&entity.EntityConfig{
		Schema: t.SchemaMeta,
		RW:     buffer.NewReadWriter(t.BufMeta),
	})
	if err != nil {
		t.Logger.Fatal(err)
	}
	return meta
}

func (t *Table) NewRow() *record.Row {
	return record.NewRow(t.NewEntity(), t.NewMetaEntity())
}

func (t *Table) LoadRow(id uint64) *record.Row {
	row := record.NewRow(t.NewEntity(), t.NewMetaEntity())
	if err := row.SetID(id); err != nil {
		t.Logger.Fatal(err)
	}

	return row
}

func (t *Table) LockInsert() {
	t.insertMutex.Lock()
}

func (t *Table) UnlockInsert() {
	t.insertMutex.Unlock()
}

func (t *Table) LockImport() {
	t.importMutex.Lock()
	t.insertMutex.Lock()
}

func (t *Table) UnlockImport() {
	t.importMutex.Unlock()
	t.insertMutex.Unlock()
}

func (t *Table) GrowRows(count uint64) error {
	if !t.SchemaData.IsLocked() {
		return fmt.Errorf("schema is not locked")
	}
	rowSize := t.RowSize.Load()
	if rowSize == 0 {
		return fmt.Errorf("row size is not initialized")
	}
	bytesNeeded := int(count * uint64(rowSize))
	return t.BufData.Grow(bytesNeeded)
}
